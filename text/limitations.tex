\shorthandoff{'}
\begin{markdown*}{%
  hybrid,
  definitionLists,
  footnotes,
  inlineFootnotes,
  hashEnumerators,
  fencedCode,
  citations,
  citationNbsps,
  pipeTables,
  tableCaptions,
}

\chapter{Limitations}

\section{Only one Context per Machine instance}

From the beginning, the design of Jaculus-machine was to have only one Context per machine. It seemed not to be a limiting factor and simplified implementation. Now it starts to show it was a wrong decision and proves to be a limiting factor in some cases.

For example, in REPL, all exceptions should be caught and reported to standard output. When starting REPL from a JavaScript program, the main program should crash on unhandled exceptions, whereas the REPL should not. Implementation of this would require REPL and the main program to be executed in separate contexts to distinguish between their behavior regarding exception handling.


\section{Unhandled promise rejections not being reported}

This is a limitation of QuickJS. Although QuickJS does have a mechanism for reporting unhandled promise rejections, it reports some false positives. Consider the following example:

``` js
new Promise((resolve, reject) => {
    console.log("promise");
    reject(null);
}).then(() => {
    console.log("ok");
}).catch(() => {
    console.log("error");
});

console.log("after");
```

The promise is created and immediately rejected. At that moment, the promise does not have a rejection handler, and thus QuickJS reports an unhandled promise rejection. However, the handler is added before the promise goes out of scope and handles the rejection.

Fortunately, this is not a problem for well-written code, which handles all possible promise rejections. However, when an unhandled promise rejection occurs, it is not reported, which may lead to errors that are difficult to debug.

To fix this, modifying QuickJS internals would be required, which is outside the scope of this work, but it is an essential consideration for future work.


\section{ESP32 filesystem API}

As the filesystem MFeature is implemented using C++ `std::filesystem`, which is not yet fully supported by the ESP-IDF, some of its functionality might not work, and some may even block the runtime.

The broken functionality involves listing directories -- `readdir` and `rmdir`. Fortunately, working with files works without a problem, which is an essential functionality for loading JavaScript files.


\section{Compatibility with other platforms}

Through implementing all of the created components, I have focused on only using the standard C++20 library. This worked well for development, as all of the functionality could be tested locally on a desktop PC, and later everything could be easily integrated with the ESP-IDF. Unfortunately, after briefly exploring development options of platforms other than ESP32 (STM32, RP2040), I have discovered that the C++20 standard is often not fully supported.

This has dealt a significant blow to the portability of these components, which will have to be partially rewritten to support other platforms. Primarily, an abstraction layer around the filesystem API and asynchronous elements (threads, synchronization primitives) will have to be implemented.


\shorthandon{'}
\end{markdown*}
