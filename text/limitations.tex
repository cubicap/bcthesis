\shorthandoff{'}
\begin{markdown*}{%
  hybrid,
  definitionLists,
  footnotes,
  inlineFootnotes,
  hashEnumerators,
  fencedCode,
  citations,
  citationNbsps,
  pipeTables,
  tableCaptions,
}

\chapter{Limitations}

This chapter describes the limitations of the created components and the Jaculus-esp32 firmware. While the problems described here are not critical, they cause some inconvenience and should be addressed in the future.

\section{Only one Context per Machine instance}

From the beginning, the design of Jaculus-machine was to have only one Context per machine. It seemed not to be a limiting factor and simplified implementation. However, later in development, it started to show it was a wrong decision and proves to be a limiting factor in some cases.

For example, in REPL, all exceptions should be caught and reported to standard output. When starting REPL from a JavaScript program, the main program should crash on unhandled exceptions, whereas the REPL should not. Implementation of this would require REPL and the main program to be executed in separate contexts to distinguish between their behavior regarding exception handling.


\section{Unhandled promise rejections not being reported}

This is a limitation of QuickJS. Although QuickJS does have a mechanism for reporting unhandled promise rejections, it reports some false positives. Consider the following example:

``` js
new Promise((resolve, reject) => {
    console.log("promise");
    reject(null);
}).then(() => {
    console.log("ok");
}).catch(() => {
    console.log("error");
});

console.log("after");
```

The promise is created and immediately rejected. At that moment, the promise does not have a rejection handler, and thus QuickJS reports an unhandled promise rejection. However, the handler is added before the promise goes out of scope and handles the rejection.

Because of the false positives, the mechanism for reporting unhandled promise rejections is disabled in Jaculus-machine.

Fortunately, this is not a problem for well-written code, which correctly handles all possible promise rejections. However, when an unhandled promise rejection occurs, it is not reported, which may lead to errors that are difficult to debug.

To fix this, modifying QuickJS internals would be required, which is outside the scope of this work, but it is an essential consideration for future work.


\section{Filesystem API}

As the Filesystem MFeature is implemented using C++ `std::filesystem` API, which is not yet fully supported by the ESP-IDF, some of its functionality does not work, and some may even block the runtime indefinitely.

The broken functionality involves listing directories --- `readdir` and `rmdir`. Fortunately, working with files works without a problem, which is an essential functionality for loading JavaScript files.

It would be possible to separately reimplement the MFeature to use the POSIX API, but it would make more sense to implement a more complex abstraction layer around the filesystem API, which could be used by other Jaculus components as well. However, that would require a significant amount of work, which is not strictly necessary for the functionality of Jaculus-esp32.

\section{Compatibility with other platforms}

Through implementing all of the created components, I have focused on only using the standard C++20 library. This worked well for development, as all of the functionality could be tested locally on a desktop PC, and later everything could be easily integrated with the ESP-IDF. Unfortunately, after briefly exploring development options of platforms other than ESP32 (STM32, RP2040), I have discovered that the C++20 standard is often not fully supported. Some platforms do not even fully support older standards, such as C++17.

This has dealt a significant blow to the portability of these components, which would have to be partially rewritten to support other platforms. Primarily, an abstraction layer around the filesystem API and asynchronous elements (threads, synchronization primitives) would have to be implemented.


\shorthandon{'}
\end{markdown*}
