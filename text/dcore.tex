\shorthandoff{'}
\begin{markdown*}{%
  hybrid,
  definitionLists,
  footnotes,
  inlineFootnotes,
  hashEnumerators,
  fencedCode,
  citations,
  citationNbsps,
  pipeTables,
  tableCaptions,
}

\chapter{Jaculus-device-core}

The Jaculus-device-core library provides a mechanism for defining a Jaculus device and controlling it.

It uses the Jaculus-machine library for the JavaScript runtime and the Jaculus-link library for communication.

% \section{Features}

%   - Jaculus-machine runtime
%   - communication via Jaculus-link
%   - control protocol for controlling and monitoring Jaculus-machine runtime
%   - uploader protocol for uploading code/data to Jaculus device

\section{Architecture}

\subsection{Device class}

The `jac::Device` class is the entry point for defining a Jaculus device. It is a template parametrized by the Machine type used for the JavaScript runtime. The Machine type must implement the `evalFile` method, which is used to run the code uploaded to the device.

The `jac::Device` class exposes a `jac::Router` object, which is used to connect the device to the communication channel/s. `jac::Device` also exposes an interface for controlling the internal Machine instance from C++ code.

Two services are also part of the `jac::Device` class and expose functionality over the communication channel/s:

  - Uploader - service for uploading code/data to the device
  - Controller - service for controlling and monitoring the device

Each service uses a single channel provided by the `jac::Router` object. Other channels are also reserved for the standard input and output of the Machine instance and for a global logger instance.

The `jac::Device` implements a locking mechanism to prevent multiple clients from accessing the device simultaneously. The lock is paired with a timeout, which is reset while the client communicates with the devices. If the timeout expires, the lock is released, and other clients can access the device. The lock is exposed to the client via the Controller service.


\section{Implementation}

\subsection{Controller service}

The Controller service is implemented in the `jac::Controller` class. It uses a *PacketCommunicator* interface to communicate with the client. The first byte of each packet is used to specify the command to be executed. The rest of the packet is used to transmit command-specific data.

The service provides the following functionality:

  - accessing the device lock
  - controlling the internal Machine instance
  - using the Machine instance's standard input and output
  - monitoring the device status

\subsection{Filesystem access}

The Uploader service provides access to the filesystem of the device. Unfortunately, because `std::filesystem` is not yet fully implemented in ESP-IDF, the implementation has to, in some cases, rely on the POSIX filesystem API to be portable to the ESP platform.

\subsection{Uploader service}

The Uploader service is implemented in the `jac::Uploader` class. Similarly to the Controller service, it uses a *PacketCommunicator* interface to communicate with the client. The first byte of each packet is used to specify the command to be executed. The rest of the packet is used to transmit command-specific data.

The service provides the following functionality:

  - listing files and directories
  - creating and deleting directories
  - writing, reading, and deleting files

Most commands are processed in a single packet, but writing files requires the data to be sent in multiple packets. When writing a file, an internal state is set to specify what operation should be performed when data is received and when the transmission is finished. To prevent overflow of the receiving buffer, the command implements, admittedly relatively inefficient, flow control -- the client must acknowledge each packet before the next one is sent.

Commands for reading a file and listing a directory might also split the data into multiple packets. For simplicity, no flow control is implemented when transmitting data to the client, as the client is expected to be a much more powerful device that can handle the transmission.


\section{Usage}

  - defining a Jaculus device
  - controlling a Jaculus device


\shorthandon{'}
\end{markdown*}